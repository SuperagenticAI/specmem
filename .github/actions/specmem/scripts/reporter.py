#!/usr/bin/env python3
"""Format results and post PR comment.

This script formats SpecMem analysis results as markdown
and posts them as a PR comment using the GitHub API.
"""

from __future__ import annotations

import json
import os
import sys
from typing import Any

import urllib.request
import urllib.error


def format_markdown(results: dict[str, Any]) -> str:
    """Format results as markdown for PR comment.

    Args:
        results: Analysis results dictionary

    Returns:
        Formatted markdown string
    """
    coverage = results.get("coverage_percentage", 0)
    health_grade = results.get("health_grade", "N/A")
    health_score = results.get("health_score", 0)
    validation_errors = results.get("validation_errors", 0)

    # Determine status emoji
    cov_emoji = "‚úÖ" if coverage >= 80 else "‚ö†Ô∏è" if coverage >= 50 else "‚ùå"
    health_emoji = "‚úÖ" if health_grade in ["A", "B"] else "‚ö†Ô∏è" if health_grade == "C" else "‚ùå"
    val_emoji = "‚úÖ" if validation_errors == 0 else "‚ùå"

    md = f"""## üìä SpecMem Analysis

| Metric | Value | Status |
|--------|-------|--------|
| Spec Coverage | {coverage:.1f}% | {cov_emoji} |
| Health Grade | {health_grade} ({health_score:.0f}/100) | {health_emoji} |
| Validation Errors | {validation_errors} | {val_emoji} |

"""

    # Add coverage details if available
    commands = results.get("commands", {})
    if "cov" in commands:
        cov_data = commands["cov"]
        features = cov_data.get("features", [])
        if features:
            md += "\n<details>\n<summary>üìã Coverage by Feature</summary>\n\n"
            md += "| Feature | Coverage | Covered | Total |\n"
            md += "|---------|----------|---------|-------|\n"
            for f in features[:15]:  # Limit to 15 features
                name = f.get("feature_name", "unknown").replace("-", " ").title()
                pct = f.get("coverage_percentage", 0)
                tested = f.get("tested_count", 0)
                total = f.get("total_count", 0)
                md += f"| {name} | {pct:.0f}% | {tested} | {total} |\n"
            if len(features) > 15:
                md += f"\n*...and {len(features) - 15} more features*\n"
            md += "\n</details>\n"

    # Add health breakdown if available
    if "health" in commands:
        health_data = commands["health"]
        breakdown = health_data.get("breakdown", [])
        if breakdown:
            md += "\n<details>\n<summary>üíö Health Score Breakdown</summary>\n\n"
            md += "| Category | Score | Weight |\n"
            md += "|----------|-------|--------|\n"
            for item in breakdown:
                cat = item.get("category", "unknown").replace("_", " ").title()
                score = item.get("score", 0)
                weight = item.get("weight", 0)
                md += f"| {cat} | {score:.0f} | {weight:.0%} |\n"
            md += "\n</details>\n"

    # Add validation errors if any
    if "validate" in commands and validation_errors > 0:
        validate_data = commands["validate"]
        errors = validate_data.get("errors", [])
        if errors:
            md += "\n<details>\n<summary>‚ùå Validation Errors</summary>\n\n"
            for err in errors[:10]:  # Limit to 10 errors
                md += f"- {err}\n"
            if len(errors) > 10:
                md += f"\n*...and {len(errors) - 10} more errors*\n"
            md += "\n</details>\n"

    md += "\n---\n*Generated by [SpecMem](https://github.com/specmem/specmem) GitHub Action*"

    return md


def find_existing_comment(
    token: str, repo: str, pr_number: int
) -> int | None:
    """Find existing SpecMem comment on PR.

    Args:
        token: GitHub token
        repo: Repository (owner/repo)
        pr_number: PR number

    Returns:
        Comment ID if found, None otherwise
    """
    url = f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "SpecMem-Action",
    }

    req = urllib.request.Request(url, headers=headers)
    try:
        with urllib.request.urlopen(req) as response:
            comments = json.loads(response.read().decode())
            for comment in comments:
                if "SpecMem Analysis" in comment.get("body", ""):
                    return comment["id"]
    except urllib.error.HTTPError as e:
        print(f"::warning::Failed to fetch comments: {e}")

    return None


def post_comment(
    token: str, repo: str, pr_number: int, markdown: str
) -> bool:
    """Post or update PR comment.

    Args:
        token: GitHub token
        repo: Repository (owner/repo)
        pr_number: PR number
        markdown: Comment body

    Returns:
        True if successful, False otherwise
    """
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json",
        "User-Agent": "SpecMem-Action",
    }

    # Check for existing comment
    existing_id = find_existing_comment(token, repo, pr_number)

    data = json.dumps({"body": markdown}).encode()

    if existing_id:
        # Update existing comment
        url = f"https://api.github.com/repos/{repo}/issues/comments/{existing_id}"
        req = urllib.request.Request(url, data=data, headers=headers, method="PATCH")
        action = "Updated"
    else:
        # Create new comment
        url = f"https://api.github.com/repos/{repo}/issues/{pr_number}/comments"
        req = urllib.request.Request(url, data=data, headers=headers, method="POST")
        action = "Created"

    try:
        with urllib.request.urlopen(req) as response:
            if response.status in (200, 201):
                print(f"‚úÖ {action} PR comment successfully")
                return True
    except urllib.error.HTTPError as e:
        print(f"::warning::Failed to post comment: {e}")
        print(f"Response: {e.read().decode()}")

    return False


def main() -> int:
    """Main entry point.

    Returns:
        Exit code (0 for success)
    """
    # Get inputs from environment
    results_json = os.environ.get("RESULTS_JSON", "{}")
    token = os.environ.get("GITHUB_TOKEN", "")
    repo = os.environ.get("GITHUB_REPOSITORY", "")
    event_name = os.environ.get("GITHUB_EVENT_NAME", "")
    event_path = os.environ.get("GITHUB_EVENT_PATH", "")

    # Parse results
    try:
        results = json.loads(results_json)
    except json.JSONDecodeError:
        print("::warning::Failed to parse results JSON")
        results = {}

    # Format markdown
    markdown = format_markdown(results)

    # Print to logs
    print("::group::PR Comment Preview")
    print(markdown)
    print("::endgroup::")

    # Post comment if on PR
    if event_name == "pull_request" and token and repo and event_path:
        try:
            with open(event_path) as f:
                event = json.load(f)
                pr_number = event.get("pull_request", {}).get("number")
                if pr_number:
                    post_comment(token, repo, pr_number, markdown)
                else:
                    print("::warning::Could not determine PR number")
        except Exception as e:
            print(f"::warning::Failed to read event file: {e}")
    else:
        print("Not a PR event or missing token, skipping comment")

    return 0


if __name__ == "__main__":
    sys.exit(main())
